# encoding=utf8
'''
http://exercise.acmcoder.com/online/online_judge_ques?ques_id=719&konwledgeId=134
>题目描述									
	学校联欢晚会的时候，为了使每一个同学都能参与进来，主持人常常会带着同学们玩击鼓传花的游戏。游戏规则是这样的：n个同学坐着围成一个圆圈，指定一个同学手里拿着一束花，主持人在旁边背对着大家开始击鼓，鼓声开始之后拿着花的同学开始传花，每个同学都可以把花传给自己左右的两个同学中的一个（左右任意），当主持人停止击鼓时，传花停止，此时，正拿着花没传出去的那个同学就要给大家表演一个节目。
	 聪明的小赛提出一个有趣的问题：有多少种不同的方法可以使得从小赛手里开始传的花，传了m次以后，又回到小赛手里。对于传递的方法当且仅当这两种方法中，接到花的同学按接球顺序组成的序列是不同的，才视作两种传花的方法不同。比如有3个同学1号、2号、3号，并假设小赛为1号，花传了3次回到小赛手里的方式有1->2->3->1和1->3->2->1，共2种。
>输入
	输入共一行，有两个用空格隔开的整数n，m（3<=n<=30，1<=m<=30）
>输出
	输出共一行，有一个整数，表示符合题意的方法数
>样例输入
	3 3
>样例输出
	2
>时间限制
	C/C++语言：1000MS其它语言：3000MS	
>内存限制
	C/C++语言：65536KB其它语言：589824KB
'''
while True:  
	li = raw_input()  
	if not li: break
	n, m = map(int, li.split())
	a, r = [0 for i in xrange(0, n+1)], [0 for i in xrange(0, n+1)]
	a[1] = 1
	for i in xrange(1, m+1):
		for j in xrange(1, n+1):
			r[j] = a[n] + a[2] if j == 1 else a[1] + a[n-1] if j == n else a[j-1] + a[j+1]
			if i == m and j == 1:
				print(r[j])
				break
		if i == m: break
		a, r = r[:], [0 for i in xrange(0, n+1)]
